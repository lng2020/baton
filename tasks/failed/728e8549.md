# Implement plan orchestrator: Claude decomposes plans into tasks

type: feature

Implement the orchestrator that runs when a user clicks 'Start' on a plan. This spawns a Claude Code instance that reads the plan, understands the codebase, and creates concrete tasks:

1. **Add orchestrator method to `Dispatcher`** in `backend/agent.py` (or as a new function alongside):
   - `execute_plan(plan_id: str)` — runs in a background thread
   - Reads the plan file from `plans/ready/{plan_id}.plan.json`
   - Moves plan to `plans/executing/`
   - Launches Claude Code with a specific orchestrator prompt (see below)
   - Parses the output to extract tasks
   - Creates tasks via `_create_task()` for each extracted task
   - Links tasks to plan via `_link_tasks_to_plan()`
   - On success: moves plan to `plans/done/`
   - On failure: moves plan to `plans/failed/` with error

2. **Orchestrator system prompt** — create a new prompt template (can be in `backend/chat.py` or a new file `backend/orchestrator.py`):
   ```
   You are a task orchestrator for the project "{project_name}".
   
   You have been given a plan to implement. Your job is to:
   1. Read the plan carefully
   2. Explore the codebase to understand the current state
   3. Break the plan into concrete, independent tasks that can run in parallel
   
   Rules:
   - If the plan is simple (single change), output just ONE task
   - If complex, output multiple tasks that can execute simultaneously
   - Each task should be self-contained and independently executable by a Claude Code agent
   - Include specific file paths, function names, and expected behavior in each task
   - Tasks should NOT depend on each other's output (they run in parallel)
   
   Output your tasks as JSON:
   ```json
   {
     "tasks": [
       {"title": "...", "content": "...", "task_type": "feature"},
       ...
     ]
   }
   ```
   ```

3. **Wire the `/agent/plans/{plan_id}/start` endpoint** to call the orchestrator:
   - Validate plan exists and is in `draft` or `ready` status
   - Move plan to `ready` status if in `draft`
   - Launch orchestrator in background thread (use ThreadPoolExecutor)
   - Return immediately with `{status: 'executing', plan_id: ...}`

4. **Claude Code invocation for orchestrator**:
   - Use the same pattern as `_run_claude_code` in the Dispatcher but with the orchestrator prompt
   - Pass the plan content as the user message
   - Parse the JSON output from Claude's response
   - Run in the project root directory (no worktree needed — orchestrator only reads, doesn't write)
   - Use `--output-format stream-json` and parse events to capture the response text

5. **Error handling**:
   - If Claude fails to produce valid JSON tasks, mark plan as failed with the error
   - If task creation fails, mark plan as failed
   - Log orchestration events for debugging

6. **Track orchestrator state** — add an `_active_orchestrations: dict[str, Future]` to the Dispatcher or agent module so we can check if a plan is being orchestrated.